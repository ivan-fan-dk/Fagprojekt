[1mdiff --git a/.gitignore b/.gitignore[m
[1mindex 3da4858..2a17201 100644[m
[1m--- a/.gitignore[m
[1m+++ b/.gitignore[m
[36m@@ -8,7 +8,7 @@[m [mtest.py[m
 [m
 # Erik special[m
 bin/[m
[31m-data/[m
[32m+[m[32mdata/FashionMNIST/[m
 include/[m
 lib/[m
 lib64/[m
[1mdiff --git a/NLS.png b/NLS.png[m
[1mindex 9354eb7..a19903d 100644[m
Binary files a/NLS.png and b/NLS.png differ
[1mdiff --git a/opgaver/Schrodinger_c1c2.py b/opgaver/Schrodinger_c1c2.py[m
[1mindex a758294..ed25b95 100644[m
[1m--- a/opgaver/Schrodinger_c1c2.py[m
[1m+++ b/opgaver/Schrodinger_c1c2.py[m
[36m@@ -81,7 +81,7 @@[m [mcriterion = nn.MSELoss()[m
 optimizer = torch.optim.Adam(model.parameters(), lr=0.001)[m
 [m
 [m
[31m-num_epochs = 200[m
[32m+[m[32mnum_epochs = 1[m
 [m
 #setup for softadapt:[m
 [m
[36m@@ -175,13 +175,13 @@[m [mfor epoch in range(num_epochs):[m
         values_of_component_5 = [][m
 [m
       # Change 5: Update the loss function with the linear combination of all components.[m
[31m-    loss = 1000*(adapt_weights[0] * loss_PDE_real + adapt_weights[1] * loss_PDE_imag + adapt_weights[2] * loss_boundary_1 + adapt_weights[3] * loss_boundary_2 + adapt_weights[4]*loss_IC)[m
[32m+[m[32m    loss = (adapt_weights[0] * loss_PDE_real + adapt_weights[1] * loss_PDE_imag + adapt_weights[2] * loss_boundary_1 + adapt_weights[3] * loss_boundary_2 + adapt_weights[4]*loss_IC)[m
 [m
     loss.backward()[m
     optimizer.step()[m
 [m
     if (epoch + 1) % 2 == 0:[m
[31m-        print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4f}', end='\r')[m
[32m+[m[32m        print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4e}', end='\r')[m
 [m
 [m
 # Define a closure function to reevaluate the model and loss[m
[36m@@ -233,9 +233,9 @@[m [mdef closure():[m
     loss_boundary_1 = criterion(u_left, u_right)[m
 [m
       # Change 5: Update the loss function with the linear combination of all components.[m
[31m-    loss = 1000*(loss_PDE_real + loss_PDE_imag + loss_boundary_1 + loss_boundary_2 + loss_IC)[m
[32m+[m[32m    loss = (loss_PDE_real + loss_PDE_imag + loss_boundary_1 + loss_boundary_2 + loss_IC)[m
     if (epoch + 1) % 2 == 0:[m
[31m-        print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4f}', end='\r')[m
[32m+[m[32m        print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4e}', end='\r')[m
     loss.backward()[m
     return loss[m
 [m
[1mdiff --git a/opgaver/schrodringer.py b/opgaver/schrodringer.py[m
[1mindex 8ea2f0b..509f1b1 100644[m
[1m--- a/opgaver/schrodringer.py[m
[1m+++ b/opgaver/schrodringer.py[m
[36m@@ -4,8 +4,16 @@[m [mimport torch.optim as optim[m
 import matplotlib.pyplot as plt[m
 from softadapt import *[m
 import numpy as np[m
[32m+[m[32mimport scipy.io[m
[32m+[m[32mimport os[m
[32m+[m[32mfrom IPython.display import HTML[m
[32m+[m[32mfrom matplotlib.animation import FuncAnimation[m
[32m+[m[32mfrom mpl_toolkits.mplot3d import Axes3D[m
[32m+[m[32mimport matplotlib.gridspec as gridspec[m
[32m+[m[32mimport pandas as pd[m
[32m+[m[32mimport re[m
 [m
[31m-N = 50[m
[32m+[m[32mN = 200[m
 [m
 # Define boundary conditions[m
 t0 = 0.0[m
[36m@@ -55,10 +63,6 @@[m [mclass NeuralNetwork(nn.Module):[m
             nn.Tanh(),[m
             nn.Linear(100,100),[m
             nn.Tanh(),[m
[31m-            nn.Linear(100,100),[m
[31m-            nn.Tanh(),[m
[31m-            nn.Linear(100,100),[m
[31m-            nn.Tanh(),[m
             nn.Linear(100,2)[m
         )[m
 [m
[36m@@ -79,7 +83,7 @@[m [mmodel.apply(NeuralNetwork.init_weights)[m
 criterion = nn.MSELoss()[m
 optimizer = torch.optim.Adam(model.parameters(), lr=0.001)[m
 [m
[31m-num_epochs = 7000[m
[32m+[m[32mnum_epochs = 3000[m
 [m
 #setup for softadapt:[m
 [m
[36m@@ -134,17 +138,17 @@[m [mfor epoch in range(num_epochs):[m
 [m
     loss_IC = criterion(u_ic_real, phi(X_vals_))+criterion(u_ic_imag, torch.zeros_like(X_vals_))[m
 [m
[31m-    # loss_boundary_2 = criterion(bound_left